// Maze rendering using HTML5 Canvas
const DEFAULT_MARGIN = 60;
const WATERMARK_TEXT = "Generated by mazegenerator.amanr.me";

function renderMazeInternal(mazeData, options = {}) {
    const cellSize = options.cellSize || 40;
    const wallThickness = options.wallThickness || 3;
    const margin = options.margin || DEFAULT_MARGIN;
    const format = options.format || 'image/jpeg';
    const quality = options.quality ?? 0.95;
    const showStartEndCells = options.showStartEndCells ?? true;

    const width = mazeData.columns * cellSize + margin * 2;
    const height = mazeData.rows * cellSize + margin * 2;

    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, width, height);

    if (showStartEndCells) {
        mazeData.cells.forEach(cell => {
            const x = margin + cell.column * cellSize;
            const y = margin + cell.row * cellSize;

            if (cell.cellType === 'start') {
                ctx.fillStyle = '#90EE90';
                ctx.fillRect(x, y, cellSize, cellSize);
            } else if (cell.cellType === 'end') {
                ctx.fillStyle = '#FFB6C1';
                ctx.fillRect(x, y, cellSize, cellSize);
            }
        });
    }

    ctx.strokeStyle = '#000000';
    ctx.lineWidth = wallThickness;
    ctx.lineCap = 'square';

    mazeData.cells.forEach(cell => {
        const x = margin + cell.column * cellSize;
        const y = margin + cell.row * cellSize;

        if (cell.hasTopWall) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + cellSize, y);
            ctx.stroke();
        }

        if (cell.hasRightWall) {
            ctx.beginPath();
            ctx.moveTo(x + cellSize, y);
            ctx.lineTo(x + cellSize, y + cellSize);
            ctx.stroke();
        }

        if (cell.hasBottomWall) {
            ctx.beginPath();
            ctx.moveTo(x, y + cellSize);
            ctx.lineTo(x + cellSize, y + cellSize);
            ctx.stroke();
        }

        if (cell.hasLeftWall) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + cellSize);
            ctx.stroke();
        }
    });

    ctx.fillStyle = 'rgba(128, 128, 128, 0.7)';
    ctx.font = '14px Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(WATERMARK_TEXT, width / 2, height - 20);

    return canvas.toDataURL(format, quality);
}

window.mazeRenderer = {
    renderMaze: function (mazeData) {
        return renderMazeInternal(mazeData, {});
    },
    renderMazeWithOptions: function (mazeData, options) {
        return renderMazeInternal(mazeData, options || {});
    }
};

window.fileSaver = {
    saveFileFromBytes: function (fileName, base64Data, contentType) {
        if (!base64Data) {
            return;
        }

        const byteCharacters = atob(base64Data);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }

        const blob = new Blob([new Uint8Array(byteNumbers)], { type: contentType || 'application/octet-stream' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = fileName || 'maze.zip';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
    }
};
